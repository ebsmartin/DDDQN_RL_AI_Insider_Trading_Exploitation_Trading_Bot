import org.apache.storm.Config;
import org.apache.storm.task.OutputCollector;
import org.apache.storm.task.TopologyContext;
import org.apache.storm.topology.OutputFieldsDeclarer;
import org.apache.storm.topology.base.BaseRichBolt;
import org.apache.storm.tuple.Fields;
import org.apache.storm.tuple.Tuple;
import org.apache.storm.tuple.Values;
import org.apache.storm.Constants;

import java.util.*;

public class CloudLossyCountBolt extends BaseRichBolt {
    private OutputCollector collector;
    private Map<Integer, Map<String, ElementCount>> elementCountsPercloudCoverageRange;
    private int currentBucket = 0;
    private double epsilon = 0.2;  // not sure what is best to use here
    private int bucketWidth = (int) Math.ceil(1 / epsilon);
    private boolean newData = false;


    private static class ElementCount {
        int frequency;
        int error;

        ElementCount(int frequency, int error) {
            this.frequency = frequency;
            this.error = error;
        }
    }

    @Override
    public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) {
        this.collector = collector;
        this.elementCountsPercloudCoverageRange = new HashMap<>();
        this.currentBucket = 1; // Start at 1 
    }

    @Override
    public Map<String, Object> getComponentConfiguration() {
        Config conf = new Config();
        conf.put(Config.TOPOLOGY_TICK_TUPLE_FREQ_SECS, 60);
        return conf;
    }
    
    @Override
    public void execute(Tuple tuple) {
        if (tuple.getSourceComponent().equals(Constants.SYSTEM_COMPONENT_ID) && tuple.getSourceStreamId().equals(Constants.SYSTEM_TICK_STREAM_ID)) {
            if (newData) {
                pruneElements();
                reportTopStates();
                newData = false;
            }
            currentBucket++;
        } else {
            processTuple(tuple);
            newData = true;
        }
    }

    private void pruneElements() {
        elementCountsPercloudCoverageRange.forEach((cloudCoverageLevel, counts) -> {
            counts.entrySet().removeIf(entry -> entry.getValue().frequency + entry.getValue().error < currentBucket);
        });
    }

    private void processTuple(Tuple tuple) {
        String state = tuple.getStringByField("region");
        int cloudCoverage = tuple.getIntegerByField("cloudCoverage");
        int cloudCoverageLevel = getCloudCoverageLevel(cloudCoverage);
        elementCountsPercloudCoverageRange.putIfAbsent(cloudCoverageLevel, new HashMap<>());
    
        Map<String, ElementCount> counts = elementCountsPercloudCoverageRange.get(cloudCoverageLevel);
        counts.putIfAbsent(state, new ElementCount(0, currentBucket));
        ElementCount count = counts.get(state);
        count.frequency++;
    }
    
    // This method returns the cloud coverage level based on the cloud coverage percentage.
    private int getCloudCoverageLevel(int cloudCoverage) {
        if (cloudCoverage >= 0 && cloudCoverage <= 19) {
            return 1;
        } else if (cloudCoverage >= 20 && cloudCoverage <= 39) {
            return 2;
        } else if (cloudCoverage >= 40 && cloudCoverage <= 59) {
            return 3;
        } else if (cloudCoverage >= 60 && cloudCoverage <= 79) {
            return 4;
        } else { // cloudCoverage >= 80 && cloudCoverage <= 100
            return 5;
        }
    }
    
    private void reportTopStates() {
        elementCountsPercloudCoverageRange.forEach((cloudCoverageLevel, counts) -> {
            List<Map.Entry<String, ElementCount>> topStates = new ArrayList<>(counts.entrySet());
            topStates.sort((e1, e2) -> e2.getValue().frequency - e1.getValue().frequency);
            
            for (int i = 0; i < Math.min(5, topStates.size()); i++) {
                Map.Entry<String, ElementCount> entry = topStates.get(i);
                collector.emit(new Values(cloudCoverageLevel, entry.getKey(), entry.getValue().frequency));
            }
        });
    }

    @Override
    public void declareOutputFields(OutputFieldsDeclarer declarer) {
        declarer.declare(new Fields("cloudCoverageLevel", "state", "frequency"));
    }
}
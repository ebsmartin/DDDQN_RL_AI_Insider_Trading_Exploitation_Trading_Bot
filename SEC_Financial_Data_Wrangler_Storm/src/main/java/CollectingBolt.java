import org.apache.storm.task.OutputCollector;
import org.apache.storm.task.TopologyContext;
import org.apache.storm.topology.OutputFieldsDeclarer;
import org.apache.storm.topology.base.BaseRichBolt;
import org.apache.storm.tuple.Tuple;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class CollectingBolt extends BaseRichBolt {
    private OutputCollector collector;
    private FileWriter writer;
    private File currentFile;
    private volatile long lastTupleTime;
    private ScheduledExecutorService executor;
    private boolean isWriterClosed = false;
    private String directoryPath = "/s/chopin/l/grad/ebmartin/cs535/Term_Project/Storm_Data_Output/";

    Boolean hasWrittenHeader = false;

    private TopologyContext context;

    @Override
    public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) {
        this.collector = collector;
        this.context = context; // Store the context as a class member
        openNewFile(context);  // Open initial file
        this.executor = Executors.newSingleThreadScheduledExecutor();
        this.executor.scheduleAtFixedRate(this::checkLastTupleTime, 1, 1, TimeUnit.MINUTES);
    }


    private void openNewFile(TopologyContext context) {
        String filename = directoryPath + "collected_output_2007_" + context.getThisTaskId() + "_" + System.currentTimeMillis() + ".csv";
        try {
            currentFile = new File(filename);
            this.writer = new FileWriter(currentFile, true);
            this.isWriterClosed = false;
            System.out.println("CSV file is being created at: " + currentFile.getAbsolutePath());
            if (!hasWrittenHeader) {
                writer.write("SECDataHeader,timestamp,open,high,low,close,volume\n");
                hasWrittenHeader = true;
            }
        } catch (IOException e) {
            System.out.println("Error opening file: " + e.getMessage());
            e.printStackTrace();
            throw new RuntimeException("Error opening file");
        }
    }

    @Override
public void execute(Tuple tuple) {
    String Header_n_SEC_data = tuple.getStringByField("Header_n_SEC_data");
    String financial_data = tuple.getStringByField("financial_data");

    if ("END".equals(Header_n_SEC_data) && "END".equals(financial_data)) {
        closeWriter();
        collector.ack(tuple);
        return;
    }

    String SECData = Header_n_SEC_data.split("\n")[1]; // single row of SEC data
    String[] financialDataRows = financial_data.split("\n"); // multiple rows of financial data

    try {
        for (int i = 1; i < financialDataRows.length; i++) {
            writer.write(SECData + "," + financialDataRows[i] + "\n");
        }
    } catch (IOException e) {
        System.out.println("Error writing to file: " + e.getMessage());
        e.printStackTrace();
        closeWriter(); // Close the current writer
        openNewFile(this.context); // Open a new file to continue writing, pass the stored context
    }
    collector.ack(tuple);
}


    @Override
    public void cleanup() {
        executor.shutdown();
        closeWriter();
    }

    private void closeWriter() {
        if (!isWriterClosed) {
            try {
                if (writer != null) {
                    writer.close();
                    isWriterClosed = true;
                    System.out.println("Closed the file writer for: " + currentFile.getAbsolutePath());
                }
            } catch (IOException e) {
                System.err.println("Error closing writer: " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    private void checkLastTupleTime() {
        if (System.currentTimeMillis() - lastTupleTime > TimeUnit.MINUTES.toMillis(2) && !isWriterClosed) {
            closeWriter();
        }
    }

    @Override
    public void declareOutputFields(OutputFieldsDeclarer declarer) {
    }
}

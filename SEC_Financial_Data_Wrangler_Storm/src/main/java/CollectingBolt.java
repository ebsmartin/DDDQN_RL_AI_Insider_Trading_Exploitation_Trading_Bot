import org.apache.storm.task.OutputCollector;
import org.apache.storm.task.TopologyContext;
import org.apache.storm.topology.OutputFieldsDeclarer;
import org.apache.storm.topology.base.BaseRichBolt;
import org.apache.storm.tuple.Tuple;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class CollectingBolt extends BaseRichBolt {
    private OutputCollector collector;
    private FileWriter writer;
    private volatile long lastTupleTime;
    private ScheduledExecutorService executor;
    private boolean isWriterClosed = false;


    Boolean hasWrittenHeader = false;

    @Override
    public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) {
        this.collector = collector;
        String directoryPath = "/s/chopin/l/grad/ebmartin/cs535/Term_Project/Storm_Data_Output/";
        String filename = directoryPath + "collected_output_2006_" + context.getThisTaskId() + "_" + System.currentTimeMillis() + ".csv";
        try {
            this.writer = new FileWriter(filename, true);
            // Get the absolute path of the file
            String absolutePath = new File(filename).getAbsolutePath();
            // Log the absolute path
            System.out.println("CSV file is being created at: " + absolutePath);
        } catch (IOException e) {
            System.out.println("Error opening file: " + e.getMessage());
            e.printStackTrace();
            throw new RuntimeException("Error opening file");
        }

        this.lastTupleTime = System.currentTimeMillis();
        this.executor = Executors.newSingleThreadScheduledExecutor();
        this.executor.scheduleAtFixedRate(this::checkLastTupleTime, 1, 1, TimeUnit.MINUTES);
    }

    @Override
    public void execute(Tuple tuple) {
        
        String Header_n_SEC_data = tuple.getStringByField("Header_n_SEC_data");
        String financial_data = tuple.getStringByField("financial_data");
    
        // Check for the "END" tuple
        if ("END".equals(Header_n_SEC_data) && "END".equals(financial_data)) {
            // Perform cleanup tasks 
            try {
                writer.flush();
                writer.close();
                isWriterClosed = true;
            } catch (IOException e) {
                throw new RuntimeException("Error closing writer");
            }
            // Acknowledge the "END" tuple
            collector.ack(tuple);
            return;
        }

        String SECDataHeader = Header_n_SEC_data.split("\n")[0];
        String financialDataHeader = "timestamp,open,high,low,close,volume";

            
    
        String SECData = Header_n_SEC_data.split("\n")[1]; // single row of SEC data
        String[] financialDataRows = financial_data.split("\n"); // multiple rows of financial data
    
        if (!hasWrittenHeader) {
            try {
                writer.write(SECDataHeader + "," + financialDataHeader + "\n");
                hasWrittenHeader = true;
            } catch (IOException e) {
                System.out.println("Error writing to file: " + e.getMessage());
                e.printStackTrace();
                throw new RuntimeException("Error writing to file");
            }
        }
    
        try {
            for (int i = 1; i < financialDataRows.length; i++) {
                writer.write(SECData + "," + financialDataRows[i] + "\n");
            }
        } catch (IOException e) {
            throw new RuntimeException("Error writing to file");
        }
        collector.ack(tuple);
    }

    @Override
    public void declareOutputFields(OutputFieldsDeclarer declarer) {
    }

    @Override
    public void cleanup() {
        executor.shutdown();
        closeWriter();
    }

    private void checkLastTupleTime() {
        if (System.currentTimeMillis() - lastTupleTime > TimeUnit.MINUTES.toMillis(2) && lastTupleTime != 0) {
            closeWriter();
        }
    }

    private void closeWriter() {
        if (!isWriterClosed) {
            try {
                if (writer != null) {
                    writer.close();
                    isWriterClosed = true;
                }
            } catch (IOException e) {
                System.err.println("Error closing writer: " + e.getMessage());
                e.printStackTrace(); // This will print the stack trace to the console
            }
        }
    }
}